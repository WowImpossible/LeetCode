20、有效括号：
26、删除有序数组中的重复项：    
                                          重点是解题思路，对题目理解不清晰：有左括号不一定要紧跟着右括号。特例：{[]}是可以，[(])不行，{}[]()可以
		                                             不好的思路：首先有两种种情况是一定可以得到FALSE结果的：1、第一个元素就是右括号；2、输入的符号是奇数个的。
			                                                正式开始编程思路：开始是从，右括号开始的，找到第一个右括号，然后往前找，一般的话，第一个右括号的前面一定跟着左括号，否则就是返回0。
			                                                然后，用循坏解决往前轮询的问题（这里就是老是出现栈溢出的问题了）。然后用‘ ’将找到的符号全部换掉。最后再比较剩下的字符串是不是全是空字符。
			                                                         出现溢出的语句有：*(s - i)         for (i = 1; (*(s - i) == ' ') && (i < count); i++);   （之前没有加上那个count的条件，导致在编译[](){}时一直出现栈溢出的问题。因为前面都变成' '了，导致循环一直在执行） 
					                原因：   i的取值没有考虑到，导致i一直在加或者减。
		                                            优秀的思路：利用了ASCII码值的关系来写的。【'('与')'的ASCII值差1，'['与']'，'{'与'}'的ASCII值差2】：用一个数组将左括号全部放起来，然后遇到右括号的时候将其进行ASCII的比较最后的得到结果。
					        bool isValid(char* s) {

						int length=0;//定义字符串长度
						while(*(s+length))length++;//获取字符串长度
						char* ptr=(char*)malloc(length/2);//分配内存空间
						memset(ptr,0,length/2);//初始化内存空间
						int i,a=0;
						for(i=0;i<length;i++)
						{
  							  if((*(s+i)=='(')||(*(s+i)=='{')||(*(s+i)=='['))
    							{	
       								 a++;
       								 *(ptr+a)=*(s+i);
  							 }
    							//'('与')'的ASCII值差1，'['与']'，'{'与'}'的ASCII值差2
    							else if((*(s+i)==(*(ptr+a)+1))||(*(s+i)==(*(ptr+a)+2)))
   							 {
        								a--;
   							 }
    							else return 0;
						}
						if(a)
   							 return 0;
						return 1;
					}
，	                                    遇到的问题：1、老是遇到数组溢出的问题。总是。（最最最最重要的一点）
	                                                       2、对for循环的理解不通透。才导致数组超出范围。
                                                             原因：没有明确指示字符串的大小，这时候计算机自动识别并分配存储空间，
		                                          之后要对字符串进行拼接，就会导致原先开辟的存储空间是不够用的，所以就会破环原变量周围的堆栈区。